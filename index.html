<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hot Potato Game Prototype</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            min-height: 100vh;
        }

        .game-container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 400px 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 20px;
            height: calc(100vh - 40px);
        }

        .player {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
        }

        .player.active {
            border: 3px solid #ffd700;
            box-shadow: 0 8px 32px rgba(255,215,0,0.5);
        }

        .player-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #eee;
        }

        .player-name {
            font-size: 20px;
            font-weight: bold;
            color: #333;
        }

        .potato-coins {
            background: #ffd700;
            padding: 5px 12px;
            border-radius: 20px;
            font-weight: bold;
            color: #333;
        }

        .farm {
            background: linear-gradient(135deg, #8b4513, #654321);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
            color: white;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .farm.frozen {
            background: linear-gradient(135deg, #4a90e2, #2874d4);
        }

        .farm-icon {
            font-size: 24px;
            margin-bottom: 5px;
        }

        .farm-timer {
            font-size: 11px;
            font-weight: bold;
        }

        .farm-speed {
            font-size: 9px;
            opacity: 0.8;
            margin-top: 3px;
        }

        .hands-container {
            margin-bottom: 15px;
        }

        .hand {
            background: #f5f5f5;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 8px;
            min-height: 80px;
        }

        .hand.frozen {
            background: #b8e0f0;
            border-color: #4a90e2;
            position: relative;
        }

        .hand.frozen::after {
            content: '‚ùÑÔ∏è FROZEN';
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 10px;
            color: #4a90e2;
            font-weight: bold;
        }

        .potato {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            border-radius: 20px;
            padding: 10px;
            margin: 5px 0;
            color: white;
            font-size: 12px;
            position: relative;
        }

        .potato.hot {
            animation: pulse 0.5s infinite;
            background: linear-gradient(135deg, #e74c3c, #c0392b);
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .potato-name {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .potato-timer {
            font-size: 10px;
            margin-top: 5px;
        }

        .potato-actions {
            margin-top: 8px;
            display: flex;
            gap: 5px;
        }

        .store {
            grid-column: 2;
            grid-row: 1 / 3;
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            overflow-y: auto;
        }

        .store-header {
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            color: #333;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid #e67e22;
        }

        .store-potato {
            background: #f9f9f9;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
        }

        .store-potato-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .store-potato-name {
            font-weight: bold;
            color: #e67e22;
        }

        .store-potato-price {
            background: #ffd700;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
        }

        .store-potato-desc {
            font-size: 11px;
            color: #666;
            margin-bottom: 8px;
        }

        .player-controls {
            margin-top: 10px;
        }

        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 11px;
            font-weight: bold;
            transition: all 0.2s;
        }

        button:hover {
            background: #2980b9;
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        button.buy-btn {
            background: #27ae60;
        }

        button.buy-btn:hover {
            background: #229954;
        }

        button.sell-btn {
            background: #e74c3c;
        }

        button.sell-btn:hover {
            background: #c0392b;
        }

        button.buy-hand-btn {
            background: #9b59b6;
            width: 100%;
            margin-top: 10px;
        }

        button.buy-hand-btn:hover {
            background: #8e44ad;
        }

        button:disabled {
            background: #95a5a6;
            cursor: not-allowed;
            transform: none;
        }

        select {
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #ddd;
            font-size: 11px;
            margin-left: 5px;
        }

        .log {
            background: rgba(255,255,255,0.9);
            border-radius: 8px;
            padding: 10px;
            margin-top: 20px;
            max-height: 150px;
            overflow-y: auto;
            font-size: 11px;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 3px;
            border-left: 3px solid #3498db;
            padding-left: 8px;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="player" id="player0" data-player-id="0">
            <div class="player-header">
                <div class="player-name">Player 1</div>
                <div class="potato-coins"><span class="coins">10</span> PC</div>
            </div>
            <div class="hands-container"></div>
            <div class="player-controls">
                <button class="buy-hand-btn" onclick="buyHand(0)">Buy Hand (5 PC)</button>
            </div>
        </div>

        <div class="store">
            <div class="store-header">ü•î POTATO STORE ü•î</div>
            <div id="store-inventory"></div>
            <div class="log" id="game-log"></div>
        </div>

        <div class="player" id="player1" data-player-id="1">
            <div class="player-header">
                <div class="player-name">Player 2</div>
                <div class="potato-coins"><span class="coins">10</span> PC</div>
            </div>
            <div class="hands-container"></div>
            <div class="player-controls">
                <button class="buy-hand-btn" onclick="buyHand(1)">Buy Hand (5 PC)</button>
            </div>
        </div>

        <div class="player" id="player2" data-player-id="2">
            <div class="player-header">
                <div class="player-name">Player 3</div>
                <div class="potato-coins"><span class="coins">10</span> PC</div>
            </div>
            <div class="hands-container"></div>
            <div class="player-controls">
                <button class="buy-hand-btn" onclick="buyHand(2)">Buy Hand (5 PC)</button>
            </div>
        </div>

        <div class="player" id="player3" data-player-id="3">
            <div class="player-header">
                <div class="player-name">Player 4</div>
                <div class="potato-coins"><span class="coins">10</span> PC</div>
            </div>
            <div class="hands-container"></div>
            <div class="player-controls">
                <button class="buy-hand-btn" onclick="buyHand(3)">Buy Hand (5 PC)</button>
            </div>
        </div>
    </div>

    <script>
        // ============ GAME CONFIGURATION ============
        // Easy to modify game constants
        const CONFIG = {
            STARTING_COINS: 10,
            HAND_COST: 5,
            TICK_INTERVAL: 100, // milliseconds
            FARM_INTERVAL: 30000, // 30 seconds in ms
            BTC_HISTORY_TIME: 600000, // 10 minutes in ms
            BTC_RESEND_COST_PERCENT: 0.30, // 30% cost
        };

        // ============ POTATO TYPES ============
        // Easy to add/modify potato types
        const POTATO_TYPES = {
            GOLDEN: {
                name: "Golden Potato",
                basePrice: 3,
                timeUntilHot: 10000, // ms
                timeUntilBurn: 20000, // ms
                burnEffect: (playerId, handId) => {
                    log(`üí∞ Golden Potato disappeared!`);
                    freezeHand(playerId, handId, 60000); // freeze for 1 minute
                },
                tossEffect: (potato, fromPlayerId, toPlayerId) => {
                    // Increment toss count
                    potato.tosses = (potato.tosses || 0) + 1;

                    // Give coins equal to toss count
                    const fromPlayer = gameState.players[fromPlayerId];
                    fromPlayer.coins += potato.tosses;
                    log(`üí∞ Player ${fromPlayerId + 1} got ${potato.tosses} PC from tossing Golden Potato!`);

                    // Degrade timer by 10%
                    potato.heatModifier = (potato.heatModifier || 1) + 0.1;
                    log(`‚è±Ô∏è Golden Potato heating up 10% faster!`);
                },
                description: "Each toss gives you PC equal to toss count (1st=1 PC, 2nd=2 PC, etc). Timer degrades 10% per throw."
            },

            HOME_FRY: {
                name: "Home Fry Potato",
                basePrice: 8,
                timeUntilHot: 15000,
                timeUntilBurn: 25000,
                burnEffect: (playerId, handId) => {
                    log(`üçü Home Fry Potato burned! Player ${playerId + 1} frozen for 3 mins!`);
                    freezeHand(playerId, handId, 180000); // freeze for 3 minutes
                },
                tossEffect: (potato, fromPlayerId, toPlayerId) => {
                    // Lose 10% value each throw
                    potato.currentValue = (potato.currentValue || potato.basePrice) * 0.9;
                    log(`üìâ Home Fry value dropped to ${potato.currentValue.toFixed(1)} PC!`);
                },
                givesExtraSlots: true, // Special property
                extraSlots: 2,
                description: "Gives 2 extra potato slots while held. Freezes 3 mins. Loses 10% value per throw."
            },

            BTC: {
                name: "BTC Potato",
                basePrice: 5,
                timeUntilHot: 8000,
                timeUntilBurn: 15000,
                burnEffect: (playerId, handId) => {
                    const player = gameState.players[playerId];
                    log(`üí£ BTC Potato EXPLODED! Player ${playerId + 1} frozen for 1 min!`);
                    freezeHand(playerId, handId, 60000); // freeze for 1 minute

                    // Destroy a random other potato in hand
                    const otherHands = player.hands.filter((h, idx) => idx !== handId && h.potato && !h.frozen);
                    if (otherHands.length > 0) {
                        const randomHand = otherHands[Math.floor(Math.random() * otherHands.length)];
                        const destroyedPotato = randomHand.potato;
                        log(`üí• BTC destroyed ${POTATO_TYPES[destroyedPotato.type].name}!`);
                        randomHand.potato = null;
                        cleanupExcessHands(playerId);
                    }
                },
                tossEffect: (potato, fromPlayerId, toPlayerId) => {
                    // Gain 20% value each throw
                    if (!potato.currentValue) potato.currentValue = potato.basePrice;
                    potato.currentValue *= 1.2;
                    log(`üìà BTC Potato value increased to ${potato.currentValue.toFixed(1)} PC!`);
                },
                description: "Gains 20% value per toss. Costs 30% to resend within 10 mins. Explodes & destroys random potato."
            },

            PRODUCTIVITY: {
                name: "Productivity Potato",
                getDynamicPrice: (playerId) => {
                    const player = gameState.players[playerId];
                    return Math.max(8, Math.ceil(player.coins * 0.5));
                },
                basePrice: 8, // minimum price
                timeUntilHot: 12000,
                timeUntilBurn: 20000,
                burnEffect: (playerId, handId) => {
                    const player = gameState.players[playerId];
                    log(`‚ö° Productivity Potato EXPLODED! Farm frozen for 1 hour!`);
                    player.farmFrozenUntil = Date.now() + 3600000; // 1 hour
                    freezeHand(playerId, handId, 60000); // freeze hand for 1 minute
                },
                tossEffect: (potato, fromPlayerId, toPlayerId) => {
                    // 25% chance sender gets same potato recipient gets from their farm
                    if (Math.random() < 0.25) {
                        const toPlayer = gameState.players[toPlayerId];
                        toPlayer.pendingProductivityBonus = fromPlayerId;
                        log(`üéÅ Player ${fromPlayerId + 1} will get Player ${toPlayerId + 1}'s next farm potato!`);
                    }
                },
                doublesProduction: true, // Special property for farm
                description: "Costs 50% of coins (min 8 PC). Doubles farm speed (stacks). 25% chance to get recipient's next farm potato. Explosion freezes farm 1hr."
            }
        };

        // ============ GAME STATE ============
        let gameState = {
            players: [],
            nextPotatoId: 0
        };

        // ============ INITIALIZATION ============
        function initGame() {
            gameState.players = [0, 1, 2, 3].map(id => ({
                id,
                coins: CONFIG.STARTING_COINS,
                hands: [{ potato: null, frozen: false, frozenUntil: 0 }],
                farmNextProduction: Date.now() + CONFIG.FARM_INTERVAL,
                farmFrozenUntil: 0,
                btcHistory: [], // Track who received BTC potatoes and when
                pendingProductivityBonus: null // For productivity potato sharing
            }));

            renderAll();
            setInterval(gameTick, CONFIG.TICK_INTERVAL);
        }

        // ============ GAME LOOP ============
        function gameTick() {
            const now = Date.now();
            let needsRender = false;

            gameState.players.forEach((player, playerId) => {
                // Check farm production
                if (now >= player.farmNextProduction && (player.farmFrozenUntil === 0 || now >= player.farmFrozenUntil)) {
                    produceFarmPotato(playerId);
                    needsRender = true;
                }

                player.hands.forEach((hand, handId) => {
                    // Unfreeze hands
                    if (hand.frozen && now >= hand.frozenUntil) {
                        hand.frozen = false;
                        hand.frozenUntil = 0;
                        log(`üî• Player ${playerId + 1}'s hand thawed!`);
                        needsRender = true;
                    }

                    // Update potato timers
                    if (hand.potato) {
                        const potato = hand.potato;
                        const heatMod = potato.heatModifier || 1;
                        const type = POTATO_TYPES[potato.type];

                        // Check if burned
                        if (now >= potato.burnTime) {
                            type.burnEffect(playerId, handId);
                            hand.potato = null;
                            cleanupExcessHands(playerId);
                            needsRender = true;
                            renderAll();
                            return;
                        }

                        // Check if became hot
                        if (!potato.isHot && now >= potato.hotTime) {
                            potato.isHot = true;
                            needsRender = true;
                        }
                    }
                });
            });

            // Only render every 10 ticks (once per second) unless something important changed
            if (!gameState.tickCount) gameState.tickCount = 0;
            gameState.tickCount++;

            if (needsRender || gameState.tickCount % 10 === 0) {
                renderAll();
            }
        }

        // ============ HELPER FUNCTIONS ============
        function getBonusSlots(playerId) {
            const player = gameState.players[playerId];
            let bonusSlots = 0;

            // Check for potatoes that give extra slots
            player.hands.forEach(hand => {
                if (hand.potato) {
                    const type = POTATO_TYPES[hand.potato.type];
                    if (type.givesExtraSlots) {
                        bonusSlots += type.extraSlots;
                    }
                }
            });

            return bonusSlots;
        }

        function getAvailableHandCount(playerId) {
            const player = gameState.players[playerId];
            const bonusSlots = getBonusSlots(playerId);

            // Available slots = actual hands + bonus slots from potatoes
            return player.hands.length + bonusSlots;
        }

        function getUsedHandCount(playerId) {
            const player = gameState.players[playerId];
            return player.hands.filter(h => h.potato).length;
        }

        function cleanupExcessHands(playerId) {
            const player = gameState.players[playerId];
            const bonusSlots = getBonusSlots(playerId);
            const usedSlots = player.hands.filter(h => h.potato).length;

            // Maximum hands we should have = used slots (but at least 1)
            const maxHandsNeeded = Math.max(1, usedSlots);

            // Remove empty hands from the end until we're at the right count
            while (player.hands.length > maxHandsNeeded) {
                const lastHand = player.hands[player.hands.length - 1];
                if (!lastHand.potato && !lastHand.frozen) {
                    player.hands.pop();
                    log(`üóëÔ∏è Player ${playerId + 1} lost an empty hand slot`);
                } else {
                    // If the last hand has a potato or is frozen, we can't remove it
                    break;
                }
            }
        }

        function getProductivityCount(playerId) {
            const player = gameState.players[playerId];
            let count = 0;
            player.hands.forEach(hand => {
                if (hand.potato && hand.potato.type === 'PRODUCTIVITY') {
                    count++;
                }
            });
            return count;
        }

        function getFarmInterval(playerId) {
            const productivityCount = getProductivityCount(playerId);
            // Each productivity potato halves the time (doubles speed)
            return CONFIG.FARM_INTERVAL / Math.pow(2, productivityCount);
        }

        function produceFarmPotato(playerId) {
            const player = gameState.players[playerId];
            const now = Date.now();

            // Pick random potato type
            const potatoTypes = Object.keys(POTATO_TYPES);
            const randomType = potatoTypes[Math.floor(Math.random() * potatoTypes.length)];
            const type = POTATO_TYPES[randomType];

            log(`üåæ Player ${playerId + 1}'s farm produced a ${type.name}!`);

            // Add to player's hand if space available
            const availableSlots = getAvailableHandCount(playerId);
            const usedSlots = getUsedHandCount(playerId);

            if (usedSlots < availableSlots || player.hands.some(h => !h.potato && !h.frozen)) {
                let emptyHand = player.hands.find(h => !h.potato && !h.frozen);
                if (!emptyHand && usedSlots < availableSlots) {
                    player.hands.push({ potato: null, frozen: false, frozenUntil: 0 });
                    emptyHand = player.hands[player.hands.length - 1];
                }

                if (emptyHand) {
                    emptyHand.potato = {
                        id: gameState.nextPotatoId++,
                        type: randomType,
                        basePrice: type.basePrice,
                        currentValue: type.basePrice,
                        heatModifier: 1,
                        tosses: 0,
                        isHot: false,
                        hotTime: now + type.timeUntilHot,
                        burnTime: now + type.timeUntilBurn,
                        createdAt: now
                    };

                    // Handle productivity potato bonus
                    if (player.pendingProductivityBonus !== null) {
                        const bonusPlayerId = player.pendingProductivityBonus;
                        const bonusPlayer = gameState.players[bonusPlayerId];

                        // Give same potato to the bonus player
                        const bonusAvailable = getAvailableHandCount(bonusPlayerId);
                        const bonusUsed = getUsedHandCount(bonusPlayerId);

                        if (bonusUsed < bonusAvailable || bonusPlayer.hands.some(h => !h.potato && !h.frozen)) {
                            let bonusHand = bonusPlayer.hands.find(h => !h.potato && !h.frozen);
                            if (!bonusHand && bonusUsed < bonusAvailable) {
                                bonusPlayer.hands.push({ potato: null, frozen: false, frozenUntil: 0 });
                                bonusHand = bonusPlayer.hands[bonusPlayer.hands.length - 1];
                            }

                            if (bonusHand) {
                                bonusHand.potato = {
                                    id: gameState.nextPotatoId++,
                                    type: randomType,
                                    basePrice: type.basePrice,
                                    currentValue: type.basePrice,
                                    heatModifier: 1,
                                    tosses: 0,
                                    isHot: false,
                                    hotTime: now + type.timeUntilHot,
                                    burnTime: now + type.timeUntilBurn,
                                    createdAt: now
                                };
                                log(`üéÅ Player ${bonusPlayerId + 1} also got a ${type.name} from Productivity bonus!`);
                            }
                        }

                        player.pendingProductivityBonus = null;
                    }
                }
            } else {
                log(`‚ùå Player ${playerId + 1}'s farm potato wasted - no space!`);
            }

            // Schedule next production
            player.farmNextProduction = now + getFarmInterval(playerId);
        }

        function getBTCSendCost(fromPlayerId, toPlayerId, potatoValue) {
            const fromPlayer = gameState.players[fromPlayerId];
            const now = Date.now();

            // Clean up old history
            fromPlayer.btcHistory = fromPlayer.btcHistory.filter(entry =>
                now - entry.timestamp < CONFIG.BTC_HISTORY_TIME
            );

            // Check if recipient sent BTC to this player recently (sending it back)
            const recentReceive = fromPlayer.btcHistory.find(entry => entry.fromPlayerId === toPlayerId);

            if (recentReceive) {
                return Math.ceil(potatoValue * CONFIG.BTC_RESEND_COST_PERCENT);
            }

            return 0;
        }

        // ============ ACTIONS ============
        function buyPotato(playerId, potatoType) {
            const player = gameState.players[playerId];
            const type = POTATO_TYPES[potatoType];

            // Get actual price (dynamic for Productivity)
            const actualPrice = type.getDynamicPrice ? type.getDynamicPrice(playerId) : type.basePrice;

            if (player.coins < actualPrice) {
                log(`‚ùå Player ${playerId + 1} doesn't have enough coins! Need ${actualPrice} PC`);
                return;
            }

            const availableSlots = getAvailableHandCount(playerId);
            const usedSlots = getUsedHandCount(playerId);

            if (usedSlots >= availableSlots) {
                log(`‚ùå Player ${playerId + 1} has no free slots! (${usedSlots}/${availableSlots} used)`);
                return;
            }

            // Try to find an empty hand
            let emptyHand = player.hands.find(h => !h.potato && !h.frozen);

            // If no empty hand exists but we have bonus slots available, create a new hand
            if (!emptyHand && usedSlots < availableSlots) {
                player.hands.push({ potato: null, frozen: false, frozenUntil: 0 });
                emptyHand = player.hands[player.hands.length - 1];
                log(`‚úã Player ${playerId + 1} used a bonus slot!`);
            }

            if (!emptyHand) {
                log(`‚ùå Player ${playerId + 1} has no free hands!`);
                return;
            }

            player.coins -= actualPrice;
            const now = Date.now();
            emptyHand.potato = {
                id: gameState.nextPotatoId++,
                type: potatoType,
                basePrice: type.basePrice,
                currentValue: type.basePrice,
                heatModifier: 1,
                tosses: 0,
                isHot: false,
                hotTime: now + type.timeUntilHot,
                burnTime: now + type.timeUntilBurn,
                createdAt: now
            };

            log(`‚úÖ Player ${playerId + 1} bought ${type.name} for ${type.basePrice} PC`);
            renderAll();
        }

        function sellPotato(playerId, handId) {
            const player = gameState.players[playerId];
            const hand = player.hands[handId];

            if (!hand.potato) return;

            const potato = hand.potato;
            const sellPrice = potato.currentValue || potato.basePrice;

            player.coins += sellPrice;
            log(`üí∞ Player ${playerId + 1} sold ${POTATO_TYPES[potato.type].name} for ${sellPrice} PC`);
            hand.potato = null;

            cleanupExcessHands(playerId);
            renderAll();
        }

        function tossPotato(fromPlayerId, handId, toPlayerId) {
            const fromPlayer = gameState.players[fromPlayerId];
            const toPlayer = gameState.players[toPlayerId];
            const hand = fromPlayer.hands[handId];

            if (!hand.potato) return;

            const potato = hand.potato;
            const type = POTATO_TYPES[potato.type];

            // Check BTC send cost
            if (potato.type === 'BTC') {
                const sendCost = getBTCSendCost(fromPlayerId, toPlayerId, potato.currentValue || potato.basePrice);
                if (sendCost > 0) {
                    if (fromPlayer.coins < sendCost) {
                        log(`‚ùå Player ${fromPlayerId + 1} needs ${sendCost} PC to send BTC back to Player ${toPlayerId + 1}!`);
                        return;
                    }
                    fromPlayer.coins -= sendCost;
                    log(`üí∏ Player ${fromPlayerId + 1} paid ${sendCost} PC to send BTC back!`);
                }

                // Record this send in recipient's history (they received from fromPlayer)
                toPlayer.btcHistory.push({
                    fromPlayerId: fromPlayerId,
                    timestamp: Date.now()
                });
            }

            // Check if target player has available slots
            const availableSlots = getAvailableHandCount(toPlayerId);
            const usedSlots = getUsedHandCount(toPlayerId);

            if (usedSlots >= availableSlots) {
                log(`‚ùå Player ${toPlayerId + 1} has no free slots! (${usedSlots}/${availableSlots} used)`);
                return;
            }

            let toHand = toPlayer.hands.find(h => !h.potato && !h.frozen);
            if (!toHand && usedSlots < availableSlots) {
                toPlayer.hands.push({ potato: null, frozen: false, frozenUntil: 0 });
                toHand = toPlayer.hands[toPlayer.hands.length - 1];
            }

            if (!toHand) {
                log(`‚ùå Player ${toPlayerId + 1} has no free hands!`);
                return;
            }

            // Apply toss effect (pass fromPlayerId and toPlayerId for effects that need them)
            type.tossEffect(potato, fromPlayerId, toPlayerId);

            // Restart timers from now with heat modifier applied
            const now = Date.now();
            const modifiedHotTime = type.timeUntilHot / potato.heatModifier;
            const modifiedBurnTime = type.timeUntilBurn / potato.heatModifier;

            potato.hotTime = now + modifiedHotTime;
            potato.burnTime = now + modifiedBurnTime;
            potato.isHot = false; // Reset hot status
            potato.createdAt = now; // Update creation time to now

            // Move potato
            toHand.potato = potato;
            hand.potato = null;

            log(`üîÑ Player ${fromPlayerId + 1} tossed ${type.name} to Player ${toPlayerId + 1}`);
            cleanupExcessHands(fromPlayerId);
            renderAll();
        }

        function buyHand(playerId) {
            const player = gameState.players[playerId];

            if (player.coins < CONFIG.HAND_COST) {
                log(`‚ùå Player ${playerId + 1} needs ${CONFIG.HAND_COST} PC for a new hand!`);
                return;
            }

            player.coins -= CONFIG.HAND_COST;
            player.hands.push({ potato: null, frozen: false, frozenUntil: 0 });

            log(`‚úã Player ${playerId + 1} bought a new hand!`);
            renderAll();
        }

        function freezeHand(playerId, handId, duration) {
            const hand = gameState.players[playerId].hands[handId];
            hand.frozen = true;
            hand.frozenUntil = Date.now() + duration;
            hand.potato = null; // Potato turns to ash
        }

        // ============ RENDERING ============
        function renderAll() {
            gameState.players.forEach((player, id) => {
                renderPlayer(id);
            });
            renderStore();
        }

        function renderPlayer(playerId) {
            const player = gameState.players[playerId];
            const playerEl = document.getElementById(`player${playerId}`);

            playerEl.querySelector('.coins').textContent = player.coins;

            const availableSlots = getAvailableHandCount(playerId);
            const usedSlots = getUsedHandCount(playerId);
            const bonusSlots = getBonusSlots(playerId);

            const handsContainer = playerEl.querySelector('.hands-container');

            // Render actual hands
            let handsHtml = player.hands.map((hand, handId) => {
                const frozenClass = hand.frozen ? 'frozen' : '';
                const potatoHtml = hand.potato ? renderPotatoInHand(playerId, handId, hand.potato) : '';

                return `
                    <div class="hand ${frozenClass}">
                        ${hand.frozen ? `<div style="font-size: 10px; color: #4a90e2;">Thaws in ${Math.ceil((hand.frozenUntil - Date.now()) / 1000)}s</div>` : ''}
                        ${potatoHtml}
                    </div>
                `;
            }).join('');

            // Add bonus slots (virtual hands from potatoes)
            for (let i = 0; i < bonusSlots; i++) {
                const bonusHandIndex = player.hands.length + i;
                // Check if there's a potato in this bonus slot
                const potatoesInHands = player.hands.filter(h => h.potato).map(h => h.potato);
                const bonusPotatoIndex = bonusHandIndex - player.hands.length + player.hands.filter(h => h.potato).length;

                handsHtml += `
                    <div class="hand" style="border: 2px dashed #ffd700; background: #fffbf0;">
                        <div style="font-size: 10px; color: #999; font-style: italic;">Bonus Slot ${i + 1}</div>
                    </div>
                `;
            }

            // Farm status
            const now = Date.now();
            const farmFrozen = player.farmFrozenUntil > 0 && now < player.farmFrozenUntil;
            const timeUntilProduce = farmFrozen
                ? player.farmFrozenUntil - now
                : Math.max(0, player.farmNextProduction - now);
            const productivityCount = getProductivityCount(playerId);

            const farmIcon = farmFrozen ? '‚ùÑÔ∏è' : 'üåæ';
            const farmTimerText = farmFrozen
                ? `Frozen for ${Math.ceil(timeUntilProduce / 1000 / 60)} min`
                : `Next potato in ${Math.ceil(timeUntilProduce / 1000)}s`;
            const farmSpeedText = !farmFrozen && productivityCount > 0
                ? `${Math.pow(2, productivityCount)}x Speed (${productivityCount} Productivity)`
                : '';

            handsContainer.innerHTML = `
                <div class="farm ${farmFrozen ? 'frozen' : ''}">
                    <div class="farm-icon">${farmIcon} FARM ${farmIcon}</div>
                    <div class="farm-timer">${farmTimerText}</div>
                    ${farmSpeedText ? `<div class="farm-speed">${farmSpeedText}</div>` : ''}
                </div>
                <div style="font-size: 11px; color: #666; margin-bottom: 8px;">
                    Slots: ${usedSlots}/${availableSlots} used ${bonusSlots > 0 ? `(+${bonusSlots} bonus)` : ''}
                </div>
                ${handsHtml}
            `;
        }

        function renderPotatoInHand(playerId, handId, potato) {
            const type = POTATO_TYPES[potato.type];
            const now = Date.now();
            const timeUntilBurn = Math.max(0, potato.burnTime - now);
            const hotClass = potato.isHot ? 'hot' : '';

            const otherPlayers = [0, 1, 2, 3].filter(id => id !== playerId);

            return `
                <div class="potato ${hotClass}">
                    <div class="potato-name">${type.name}</div>
                    <div style="font-size: 10px;">Value: ${(potato.currentValue || potato.basePrice).toFixed(1)} PC</div>
                    <div style="font-size: 10px;">Tosses: ${potato.tosses || 0}</div>
                    <div class="potato-timer">
                        ${potato.isHot ? 'üî• HOT! ' : ''}
                        Burns in: ${(timeUntilBurn / 1000).toFixed(1)}s
                    </div>
                    <div class="potato-actions">
                        <button class="sell-btn" onclick="sellPotato(${playerId}, ${handId})">Sell</button>
                        <div style="display: flex; gap: 3px; flex-wrap: wrap; margin-top: 5px;">
                            ${otherPlayers.map(id => {
                                const targetAvailable = getAvailableHandCount(id);
                                const targetUsed = getUsedHandCount(id);
                                const hasSpace = targetUsed < targetAvailable;

                                let costText = '';
                                if (potato.type === 'BTC') {
                                    const cost = getBTCSendCost(playerId, id, potato.currentValue || potato.basePrice);
                                    if (cost > 0) {
                                        costText = ` (-${cost})`;
                                    }
                                }

                                const disabled = !hasSpace ? 'disabled' : '';
                                return `<button ${disabled} style="flex: 1; min-width: 45px; font-size: 10px; padding: 4px 6px;" onclick="tossPotato(${playerId}, ${handId}, ${id})">‚Üí P${id + 1}${costText}</button>`;
                            }).join('')}
                        </div>
                    </div>
                </div>
            `;
        }

        function renderStore() {
            const storeEl = document.getElementById('store-inventory');
            storeEl.innerHTML = Object.keys(POTATO_TYPES).map(key => {
                const type = POTATO_TYPES[key];
                return `
                    <div class="store-potato">
                        <div class="store-potato-header">
                            <div class="store-potato-name">${type.name}</div>
                            <div class="store-potato-price">${type.basePrice} PC${type.getDynamicPrice ? ' (min)' : ''}</div>
                        </div>
                        <div class="store-potato-desc">${type.description}</div>
                        <div style="display: flex; gap: 5px;">
                            ${[0, 1, 2, 3].map(playerId => {
                                const price = type.getDynamicPrice ? type.getDynamicPrice(playerId) : type.basePrice;
                                return `<button class="buy-btn" onclick="buyPotato(${playerId}, '${key}')">P${playerId + 1} (${price})</button>`;
                            }).join('')}
                        </div>
                    </div>
                `;
            }).join('');
        }

        function log(message) {
            const logEl = document.getElementById('game-log');
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logEl.insertBefore(entry, logEl.firstChild);

            // Keep only last 20 entries
            while (logEl.children.length > 20) {
                logEl.removeChild(logEl.lastChild);
            }
        }

        // ============ START GAME ============
        initGame();
    </script>
</body>
</html>